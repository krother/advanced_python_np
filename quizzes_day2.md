
## Question 1: Pydantic Classes

Which of the following is a key benefit of using Pydantic classes in Python?

A) They automatically generate static methods
B) They enforce type validation and data parsing
C) They provide support for multiple inheritance
D) They automatically optimize code for performance


## Question 2: Object Composition

What is the main difference between composition and inheritance in object-oriented design?

A) Composition requires a class to inherit all attributes from a parent class
B) Composition involves creating objects with methods that override parent methods
C) Composition models a "has-a" relationship, while inheritance models an "is-a" relationship
D) Composition allows objects to inherit from multiple classes


## Question 3: Polymorphism

Which of the following best describes polymorphism in Python?

A) The ability for a class to inherit attributes and methods from multiple parent classes
B) The ability for different classes to define methods with the same name, which can be called through a common interface
C) A mechanism that prevents the instantiation of abstract classes
D) A feature that restricts access to private attributes and methods in a class


## Question 4: Static Methods and Functions

What is a key difference between a staticmethod and a classmethod in Python?

A) staticmethod does not receive a reference to the class or instance, while classmethod receives a reference to the class
B) staticmethod can only access instance variables, while classmethod can access class variables
C) staticmethod can be inherited, but classmethod cannot
D) staticmethod can only be called from outside the class, while classmethod must be called from within

## Question 5: Creating a Package

Which of the following steps is necessary to turn a directory of Python modules into a package?

A) Create a __init__.py file in the directory
B) Create a requirements.txt file with dependencies
C) Run setup.py to compile the modules
D) None of the above


## Question 6: Fixtures

In pytest, what is the purpose of a fixture?

A) To generate randomized test data
B) To define reusable setup and teardown code for tests
C) To run tests in a specific order
D) To automatically handle exceptions during tests


## Question 7: Test Parametrization

What is the benefit of using test parametrization in pytest?

A) It allows you to pass multiple sets of arguments to a single test function, avoiding repetition
B) It ensures that test functions execute in the correct order
C) It dynamically creates mock objects for testing
D) It disables certain tests based on conditions


## Question 8: Mocking

What does mocking allow you to do in your tests?

A) Replace real objects or functions with mock ones that simulate their behavior
B) Generate random inputs for stress testing your code
C) Automatically fix errors in the code being tested
D) Disable failed tests to avoid stopping the test suite


## Question 9: What to Test?

Which of the following should typically be the focus of unit tests?

A) Testing private methods of a class
B) Ensuring that a function or method behaves as expected given a range of inputs
C) Verifying the performance of the code under heavy load
D) Testing third-party libraries to ensure their behavior


## Question 10: Test Coverage

What does test coverage measure in automated testing?

A) The percentage of the codebase that has been executed by the tests
B) The number of test cases that have been written
C) The time taken to execute the test suite
D) The number of bugs found during testing


## Question 11: Decorators

What is the primary purpose of a decorator in Python?

A) To create a new class based on an existing one
B) To modify or extend the behavior of functions or methods without changing their code
C) To manage the state of an object
D) To handle exceptions in a function


## Question 12: Generators

Which of the following statements about Python generators is true?

A) Generators must return a value using the return statement
B) Generators use the yield keyword to produce values one at a time and can be resumed
C) Generators are not iterable objects and cannot be used in a loop
D) Generators store all values in memory until the end of iteration

## Question 13: Generators vs Iterators

How do generators differ from iterators in Python?

A) Generators are a type of iterator but are simpler to implement and use
B) Iterators must use the yield keyword, while generators do not
C) Generators are less memory-efficient than iterators
D) Iterators cannot be paused and resumed like generators


## Question 14: Classes vs Functions

When should you prefer using a class over a function?

A) When you need to create reusable, modular code with state and behavior encapsulated
B) When you only need to perform a simple operation or computation
C) When you want to avoid creating instances of objects
D) When you need a quick and temporary solution for a problem


## Question 15: Decorators and Classes

How can a decorator be applied to a method within a class?

A) By placing the decorator directly before the class definition
B) By using the decorator within the class method body
C) By placing the decorator directly before the method definition
D) By applying the decorator to the class's __init__ method only


